<!DOCTYPE html>
<html lang="en">
<head>
  <title>three.ar.js - Boilerplate</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no,
  minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      font-family: monospace;
      margin: 0;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100vh;
      -webkit-user-select: none;
      user-select: none;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>
<body>
<script src="third_party/three.js/three.js"></script>
<script src="third_party/three.js/VRControls.js"></script>
<script src="dist/three.ar.js"></script>
<script>
var vrDisplay;
var vrFrameData;
var vrControls;
var arView;

var canvas;
var camera;
var scene;
var renderer;

var hole;
var maskScene;

THREE.ARUtils.getARDisplay().then(function (display) {
  if (display) {
    vrFrameData = new VRFrameData();
    vrDisplay = display;
    init();
  } else {
    THREE.ARUtils.displayUnsupportedMessage();
  }
});

function init() {
  renderer = new THREE.WebGLRenderer({ alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.autoClear = false;
  canvas = renderer.domElement;
  document.body.appendChild(canvas);
  scene = new THREE.Scene();

  arView = new THREE.ARView(vrDisplay, renderer);

  camera = new THREE.ARPerspectiveCamera(
    vrDisplay,
    60,
    window.innerWidth / window.innerHeight,
    vrDisplay.depthNear,
    vrDisplay.depthFar
  );

  vrControls = new THREE.VRControls(camera);


  scene.background = new THREE.CubeTextureLoader()
    .setPath( 'textures/cube/Park3Med/' )
    .load( [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ] );
  maskScene = new THREE.Scene();
  //var maskGeometry = new THREE.CircleGeometry(1, 32);
  var maskGeometry = new THREE.SphereGeometry(1, 32, 32);
  var maskMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff } );
  hole = new THREE.Mesh( maskGeometry, maskMaterial );

  window.addEventListener('resize', onWindowResize, false);

  update();
}

function update() {
  renderer.clearColor();

  arView.render();

  camera.updateProjectionMatrix();

  vrDisplay.getFrameData(vrFrameData);

  vrControls.update();

  renderer.clearDepth();
  //renderer.render(scene, camera);
  mask().then(() => {
    renderer.render(scene, camera);
  });

  vrDisplay.requestAnimationFrame(update);
}

function onWindowResize () {
  console.log('setRenderer size', window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function onClick () {
  var pose = vrFrameData.pose;
  var ori = new THREE.Quaternion(
    pose.orientation[0],
    pose.orientation[1],
    pose.orientation[2],
    pose.orientation[3]
  );
  var pos = new THREE.Vector3(
    pose.position[0],
    pose.position[1],
    pose.position[2]
  );
  var dirMtx = new THREE.Matrix4();
  dirMtx.makeRotationFromQuaternion(ori);
  var push = new THREE.Vector3(0, 0, -1.0);
  push.transformDirection(dirMtx);
  pos.addScaledVector(push, 0.125);
  var clone = hole.clone();
  //maskScene.add(clone);
  scene.add(clone);
  clone.position.copy(pos);
  clone.quaternion.copy(ori);
}

function mask() {
  return new Promise((resolve, reject) => {
    //renderer.clear();
    gl.clearStencil(0);
    gl.clear(gl.STENCIL_BUFFER_BIT);
    gl.stencilFunc(gl.ALWAYS, 1, 1);
    gl.stencilOp(gl.KEEP, gl.REPLACE, gl.REPLACE);
    gl.colorMask(false, false, false, false);
    gl.enable(gl.STENCIL_TEST);
    renderer.render(maskScene, camera);

    gl.stencilFunc(gl.EQUAL, 1, 1);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    renderer.clearDepth();
    gl.colorMask(true, true, true, true);
    resolve();
  });
};




/*
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );

var renderer = new THREE.WebGLRenderer({preserveDrawingBuffer:true});
renderer.autoClear = false;
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );
var gl = renderer.domElement.getContext('webgl');

scene.background = new THREE.CubeTextureLoader()
  .setPath( 'textures/cube/Park3Med/' )
  .load( [ 'px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg' ] );

var geometry = new THREE.BoxGeometry(1, 1, 1);
var material = new THREE.MeshBasicMaterial({color:0xffff00});
var cube = new THREE.Mesh(geometry, material);
//scene.add(cube);

var maskScene = new THREE.Scene();
var maskGeometry = new THREE.CircleGeometry(1, 32);
var maskMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff } );
var maskCircle = new THREE.Mesh( maskGeometry, maskMaterial );
maskScene.add( maskCircle );

camera.position.z = 5;

function mask(maskScene) {
  return new Promise((resolve, reject) => {
    renderer.clear();
    gl.clearStencil(0);
    gl.clear(gl.STENCIL_BUFFER_BIT);
    gl.stencilFunc(gl.ALWAYS, 1, 1);
    gl.stencilOp(gl.KEEP, gl.REPLACE, gl.REPLACE);
    gl.colorMask(false, false, false, false);
    gl.enable(gl.STENCIL_TEST);
    renderer.render(maskScene, camera);

    gl.stencilFunc(gl.EQUAL, 1, 1);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    renderer.clearDepth();
    gl.colorMask(true, true, true, true);
    resolve();
  });
};

var render = function() {
  mask(maskScene).then(() => {
    renderer.render(scene, camera);
  });
};

var animate = function () {
  requestAnimationFrame( animate );

  maskCircle.rotation.x += 0.01;
  maskCircle.rotation.y += 0.01;

  cube.rotation.x -= 0.01;
  cube.rotation.y -= 0.01;

  render();
};

animate();
*/
</script>
</body>
</html>

